using System.Diagnostics;
using System.Text;

namespace zentronC.src
{
    public class Compiler
    {
        bool isAutoDeclare = false;
        public string tmpFile = "tmp.cpp";
        public bool isCppMode = false;
        public void Compile(string output)
        {
            string strCmdText = $"/C g++ -Os -s -o {output} {tmpFile}";
            Process process = new Process();
            ProcessStartInfo startInfo = new ProcessStartInfo("CMD.exe", strCmdText);
            startInfo.RedirectStandardOutput = false;
            startInfo.UseShellExecute = false;
            startInfo.CreateNoWindow = false;
            process.StartInfo = startInfo;
            process.Start();
            process.WaitForExit();
            Console.WriteLine("Finished compilation.");
        }

        public void initCompiler()
        {
            File.WriteAllText(tmpFile, "");
            File.AppendAllText(tmpFile, "/* Generated by the Zentron compiler (Written by SuperTavor) */\n");
            File.AppendAllText(tmpFile, "#include <iostream>\n");
            File.AppendAllText(tmpFile, "#include <string>\n");
            File.AppendAllText(tmpFile, "#include <unistd.h>\n");
            File.AppendAllText(tmpFile, "#include <stdlib.h>\n");
            File.AppendAllText(tmpFile, "int main()\n");
            File.AppendAllText(tmpFile, "{\n");

        }
        public void closeCompiler()
        {
            File.AppendAllText(tmpFile, "\n}");
        }
        public void writeSleep(string[] statement)
        {
            File.AppendAllText(tmpFile, $"sleep({statement[1]});\n");
        }
        public void writeUntilBegin(string[] statement)
        {
            var parsed = ParseUntil(statement);
            var v1 = parsed[1];
            var v2 = parsed[3];
            if (v1.StartsWith("&"))
            {
                v1 = v1.Substring(1);
            }
            else
            {
                v1 = $"\"{v1}\"";
            }
            if (v2.StartsWith("&"))
            {
                v2 = v2.Substring(1);
            }
            else
            {
                v2 = $"\"{v2}\"";
            }
            if (parsed[2] == ">")
            {
                File.AppendAllText(tmpFile, $"while (std::stoi({v1}) > std::stoi({v2}))\n");
                File.AppendAllText(tmpFile, "{\n");
            }
            else if (parsed[2] == "<")
            {
                File.AppendAllText(tmpFile, $"while (std::stoi({v1}) < std::stoi({v2}))\n");
                File.AppendAllText(tmpFile, "{\n");
            }
            else if (parsed[2] == "==")
            {
                File.AppendAllText(tmpFile, $"while ({v1} == {v2})\n");
                File.AppendAllText(tmpFile, "{\n");
            }
            else if (parsed[2] == "!=")
            {
                File.AppendAllText(tmpFile, $"while ({v1} != {v2})\n");
                File.AppendAllText(tmpFile, "{\n");
            }
        }
        public void writeLoop()
        {
            File.AppendAllText(tmpFile, "while(1)\n{\n");
        }
        private string[] ParseUntil(string[] statement)
        {
            var op = statement[2];

            if (op == "<")
            {
                op = ">";
            }
            else if (op == ">")
            {
                op = "<";
            }
            else if (op == "is")
            {
                op = "!=";
            }
            else if (op == "isnt")
            {
                op = "==";
            }
            else
            {
                throw new Exception("Invalid operator, cannot parse token");
            }
            statement[2] = op;
            return statement;
        }
        public void writeContinue()
        {
            File.AppendAllText(tmpFile, $"continue;\n");
        }
        public void writeBreak()
        {
            File.AppendAllText(tmpFile, $"break;\n");
        }
        public void writePrint(string[] statement)
        {
            string[] args = statement[1..^0];
            string valueToPrint = "";
            string literalIndicator = "";
            bool isNl = false;
            if (args[0] == "n")
            {
                isNl = true;
            }
            if (args[1].StartsWith("&"))
            {
                literalIndicator = "";
                valueToPrint = args[1].Substring(1);
            }
            else
            {
                valueToPrint = args[1];
                literalIndicator = "\"";
            }
            File.AppendAllText(tmpFile, $"std::cout << {literalIndicator}{valueToPrint}{literalIndicator};\n");
            if (isNl)
            {
                writeSayEmptyLine();
            }

        }
        public void writePoint(string[] statement)
        {
            string[] args = statement[1..^0];
            File.AppendAllText(tmpFile, $"{args[0]}:\n");
        }
        public void writeGo(string[] statement)
        {
            string[] args = statement[1..^0];
            File.AppendAllText(tmpFile, $"goto {args[0]};\n");
        }
        public void writeFmt(string[] statement)
        {
            string[] content = statement.Skip(1).ToArray();
            File.AppendAllText(tmpFile, "std::cout<<");
            foreach(string s in content)
            {
                string tmpString = s;
                if(s.StartsWith("&"))
                {
                    tmpString = tmpString.Substring(1);
                }
                else
                {
                    tmpString = $"\"{tmpString}\"";
                }
                if (Array.IndexOf(content,s) == 0)
                {
                    File.AppendAllText(tmpFile, $"{tmpString}");
                }
                else
                {
                    File.AppendAllText(tmpFile, $"<<{tmpString}");
                }
            }
            File.AppendAllText(tmpFile, ";\n");
        }
        public void writeIf(string[] statement,bool isElif)
        {
            string keyword = "if";
            if(isElif)
            {
                keyword = "else if";
            }
            string[] args = statement[1..^0];
            string mode = args[1];
            string v1 = args[0];
            string v2 = args[2];
            if (v1.StartsWith("&"))
            {
                v1 = v1.Substring(1);
            }
            else
            {
                v1 = $"\"{v1}\"";
            }
            if (v2.StartsWith("&"))
            {
                v2 = v2.Substring(1);
            }
            else
            {
                v2 = $"\"{v2}\"";
            }
            if (mode == "is")
            {
                File.AppendAllText(tmpFile, $"{keyword}({v1} == {v2})\n");
            }
            else if (mode == "isnt")
            {
                File.AppendAllText(tmpFile, $"{keyword}({v1} != {v2})\n");
            }
            else if (mode == "<")
            {
                File.AppendAllText(tmpFile, $"{keyword}(std::stoi({v1}) < std::stoi({v2}))");
            }
            else if (mode == ">")
            {
                File.AppendAllText(tmpFile, $"{keyword}(std::stoi({v1}) > std::stoi({v2}))");

            }
            else
            {
                throw new Exception("Invalid operator!!");
            }
            File.AppendAllText(tmpFile, "{\n");
        }
        public void writeReturnProg()
        {
            File.AppendAllText(tmpFile, "return 0;\n");
        }
        public void writeElseBegin()
        {
            File.AppendAllText(tmpFile, "else\n{\n");
        }
        public void writeEnd(string[] statement)
        {
            if (statement.Length == 1)
            {
                writeEndif();
            }
            else
            {
                throw new Exception("End recieves zero arguments!");
            }
        }
        public void writeEndif()
        {
            File.AppendAllText(tmpFile, "}\n");
        }
        public void writeDef(string[] statement)
        {
            string varname = statement[0];
            if (varname.EndsWith(";") && statement.Length == 1)
            {
                File.AppendAllText(tmpFile, $"std::string {statement[0].Substring(0, statement[0].Length - 1)} = \"\";\n");
                return;
            }
            string initialValue = statement[2];
            //File.AppendAllText("tmp.c", "//" + Unsplit(statement,' ') + "\n");
            if (initialValue.StartsWith("&"))
            {
                initialValue = initialValue.Substring(1);
            }
            else
            {
                initialValue = $"\"{initialValue}\"";
            }
            if (mainClass.createdVars.Contains(varname))
            {
                File.AppendAllText(tmpFile, $"{varname} = {initialValue};\n");
            }
            else
            {
                File.AppendAllText(tmpFile, $"std::string {varname} = {initialValue};\n");
                mainClass.createdVars.Add(statement[0]);
            }
        }
        public string Unsplit(string[] arr, char delimiter)
        {
            StringBuilder sb = new StringBuilder();

            foreach (var item in arr)
            {
                sb.Append(item).Append(delimiter);
            }

            return sb.ToString().TrimEnd();
        }

        public void writeSayEmptyLine()
        {
            File.AppendAllText(tmpFile, $"std::cout << std::endl;\n");
        }
        public void writeIn(string[] statement)
        {
            string[] args = statement[1..^0];
            string varname = args[1];
            if (isAutoDeclare)
            {
                if (!mainClass.createdVars.Contains(varname))
                {
                    File.AppendAllText(tmpFile, $"std::string {varname} = \"\";\n");
                }
            }
            File.AppendAllText(tmpFile, $"std::getline(std::cin, {varname});\n");
        }
        public void writeIncDecNum(string[] statement, bool isIncrement)
        {
            string[] args = statement.Skip(1).ToArray();
            string varname = args[0];
            string operationNum = args[2];
            char op;
            if (isIncrement)
            {
                op = '+';
            }
            else
            {
                op = '-';
            }
            File.AppendAllText(tmpFile, $"{varname} = std::to_string(std::stoi({varname}) {op} {operationNum});\n");
        }
        public void writeRule(string[] statement)
        {
            if (statement[1].ToLower() == "auto-declare")
            {
                isAutoDeclare = true;
            }
            else
            {
                throw new Exception("Invalid rule.");
            }
        }
        public void writeArithemic(string[] statement,string type)
        {
            var n1 = statement[1];
            var n2 = statement[2];
            if (n1.StartsWith("&"))
            {
                n1 = n1.Substring(1);
            }
            else
            {
                n1 = $"\"{n1}\"";
            }
            if (n2.StartsWith("&"))
            {
                n2 = n2.Substring(1);
            }
            else
            {
                n2 = $"\"{n2}\"";
            }
            var resVar = statement[4];
            if (isAutoDeclare)
            {
                if (!mainClass.createdVars.Contains(resVar))
                {
                    File.AppendAllText(tmpFile, $"std::string {resVar};\n");
                }
            }
            File.AppendAllText(tmpFile, $"{resVar} = std::to_string(std::stoi({n1}) {type} std::stoi({n2}));\n");
        }
        public void writeCpp(string[] statement)
        {
            File.AppendAllText(tmpFile, statement[1] + "\n");
        }
    }
}

